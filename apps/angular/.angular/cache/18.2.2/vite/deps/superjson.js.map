{
  "version": 3,
  "sources": ["../../../../../../../node_modules/superjson/dist/double-indexed-kv.js", "../../../../../../../node_modules/superjson/dist/registry.js", "../../../../../../../node_modules/superjson/dist/class-registry.js", "../../../../../../../node_modules/superjson/dist/util.js", "../../../../../../../node_modules/superjson/dist/custom-transformer-registry.js", "../../../../../../../node_modules/superjson/dist/is.js", "../../../../../../../node_modules/superjson/dist/pathstringifier.js", "../../../../../../../node_modules/superjson/dist/transformer.js", "../../../../../../../node_modules/superjson/dist/accessDeep.js", "../../../../../../../node_modules/superjson/dist/plainer.js", "../../../../../../../node_modules/superjson/node_modules/is-what/dist/index.js", "../../../../../../../node_modules/superjson/node_modules/copy-anything/dist/index.js", "../../../../../../../node_modules/superjson/dist/index.js"],
  "sourcesContent": ["export class DoubleIndexedKV {\n  constructor() {\n    this.keyToValue = new Map();\n    this.valueToKey = new Map();\n  }\n  set(key, value) {\n    this.keyToValue.set(key, value);\n    this.valueToKey.set(value, key);\n  }\n  getByKey(key) {\n    return this.keyToValue.get(key);\n  }\n  getByValue(value) {\n    return this.valueToKey.get(value);\n  }\n  clear() {\n    this.keyToValue.clear();\n    this.valueToKey.clear();\n  }\n}\n", "import { DoubleIndexedKV } from './double-indexed-kv.js';\nexport class Registry {\n  constructor(generateIdentifier) {\n    this.generateIdentifier = generateIdentifier;\n    this.kv = new DoubleIndexedKV();\n  }\n  register(value, identifier) {\n    if (this.kv.getByValue(value)) {\n      return;\n    }\n    if (!identifier) {\n      identifier = this.generateIdentifier(value);\n    }\n    this.kv.set(identifier, value);\n  }\n  clear() {\n    this.kv.clear();\n  }\n  getIdentifier(value) {\n    return this.kv.getByValue(value);\n  }\n  getValue(identifier) {\n    return this.kv.getByKey(identifier);\n  }\n}\n", "import { Registry } from './registry.js';\nexport class ClassRegistry extends Registry {\n  constructor() {\n    super(c => c.name);\n    this.classToAllowedProps = new Map();\n  }\n  register(value, options) {\n    if (typeof options === 'object') {\n      if (options.allowProps) {\n        this.classToAllowedProps.set(value, options.allowProps);\n      }\n      super.register(value, options.identifier);\n    } else {\n      super.register(value, options);\n    }\n  }\n  getAllowedProps(value) {\n    return this.classToAllowedProps.get(value);\n  }\n}\n", "function valuesOfObj(record) {\n  if ('values' in Object) {\n    // eslint-disable-next-line es5/no-es6-methods\n    return Object.values(record);\n  }\n  const values = [];\n  // eslint-disable-next-line no-restricted-syntax\n  for (const key in record) {\n    if (record.hasOwnProperty(key)) {\n      values.push(record[key]);\n    }\n  }\n  return values;\n}\nexport function find(record, predicate) {\n  const values = valuesOfObj(record);\n  if ('find' in values) {\n    // eslint-disable-next-line es5/no-es6-methods\n    return values.find(predicate);\n  }\n  const valuesNotNever = values;\n  for (let i = 0; i < valuesNotNever.length; i++) {\n    const value = valuesNotNever[i];\n    if (predicate(value)) {\n      return value;\n    }\n  }\n  return undefined;\n}\nexport function forEach(record, run) {\n  Object.entries(record).forEach(([key, value]) => run(value, key));\n}\nexport function includes(arr, value) {\n  return arr.indexOf(value) !== -1;\n}\nexport function findArr(record, predicate) {\n  for (let i = 0; i < record.length; i++) {\n    const value = record[i];\n    if (predicate(value)) {\n      return value;\n    }\n  }\n  return undefined;\n}\n", "import { find } from './util.js';\nexport class CustomTransformerRegistry {\n  constructor() {\n    this.transfomers = {};\n  }\n  register(transformer) {\n    this.transfomers[transformer.name] = transformer;\n  }\n  findApplicable(v) {\n    return find(this.transfomers, transformer => transformer.isApplicable(v));\n  }\n  findByName(name) {\n    return this.transfomers[name];\n  }\n}\n", "const getType = payload => Object.prototype.toString.call(payload).slice(8, -1);\nexport const isUndefined = payload => typeof payload === 'undefined';\nexport const isNull = payload => payload === null;\nexport const isPlainObject = payload => {\n  if (typeof payload !== 'object' || payload === null) return false;\n  if (payload === Object.prototype) return false;\n  if (Object.getPrototypeOf(payload) === null) return true;\n  return Object.getPrototypeOf(payload) === Object.prototype;\n};\nexport const isEmptyObject = payload => isPlainObject(payload) && Object.keys(payload).length === 0;\nexport const isArray = payload => Array.isArray(payload);\nexport const isString = payload => typeof payload === 'string';\nexport const isNumber = payload => typeof payload === 'number' && !isNaN(payload);\nexport const isBoolean = payload => typeof payload === 'boolean';\nexport const isRegExp = payload => payload instanceof RegExp;\nexport const isMap = payload => payload instanceof Map;\nexport const isSet = payload => payload instanceof Set;\nexport const isSymbol = payload => getType(payload) === 'Symbol';\nexport const isDate = payload => payload instanceof Date && !isNaN(payload.valueOf());\nexport const isError = payload => payload instanceof Error;\nexport const isNaNValue = payload => typeof payload === 'number' && isNaN(payload);\nexport const isPrimitive = payload => isBoolean(payload) || isNull(payload) || isUndefined(payload) || isNumber(payload) || isString(payload) || isSymbol(payload);\nexport const isBigint = payload => typeof payload === 'bigint';\nexport const isInfinite = payload => payload === Infinity || payload === -Infinity;\nexport const isTypedArray = payload => ArrayBuffer.isView(payload) && !(payload instanceof DataView);\nexport const isURL = payload => payload instanceof URL;\n", "export const escapeKey = key => key.replace(/\\./g, '\\\\.');\nexport const stringifyPath = path => path.map(String).map(escapeKey).join('.');\nexport const parsePath = string => {\n  const result = [];\n  let segment = '';\n  for (let i = 0; i < string.length; i++) {\n    let char = string.charAt(i);\n    const isEscapedDot = char === '\\\\' && string.charAt(i + 1) === '.';\n    if (isEscapedDot) {\n      segment += '.';\n      i++;\n      continue;\n    }\n    const isEndOfSegment = char === '.';\n    if (isEndOfSegment) {\n      result.push(segment);\n      segment = '';\n      continue;\n    }\n    segment += char;\n  }\n  const lastSegment = segment;\n  result.push(lastSegment);\n  return result;\n};\n", "import { isBigint, isDate, isInfinite, isMap, isNaNValue, isRegExp, isSet, isUndefined, isSymbol, isArray, isError, isTypedArray, isURL } from './is.js';\nimport { findArr } from './util.js';\nfunction simpleTransformation(isApplicable, annotation, transform, untransform) {\n  return {\n    isApplicable,\n    annotation,\n    transform,\n    untransform\n  };\n}\nconst simpleRules = [simpleTransformation(isUndefined, 'undefined', () => null, () => undefined), simpleTransformation(isBigint, 'bigint', v => v.toString(), v => {\n  if (typeof BigInt !== 'undefined') {\n    return BigInt(v);\n  }\n  console.error('Please add a BigInt polyfill.');\n  return v;\n}), simpleTransformation(isDate, 'Date', v => v.toISOString(), v => new Date(v)), simpleTransformation(isError, 'Error', (v, superJson) => {\n  const baseError = {\n    name: v.name,\n    message: v.message\n  };\n  superJson.allowedErrorProps.forEach(prop => {\n    baseError[prop] = v[prop];\n  });\n  return baseError;\n}, (v, superJson) => {\n  const e = new Error(v.message);\n  e.name = v.name;\n  e.stack = v.stack;\n  superJson.allowedErrorProps.forEach(prop => {\n    e[prop] = v[prop];\n  });\n  return e;\n}), simpleTransformation(isRegExp, 'regexp', v => '' + v, regex => {\n  const body = regex.slice(1, regex.lastIndexOf('/'));\n  const flags = regex.slice(regex.lastIndexOf('/') + 1);\n  return new RegExp(body, flags);\n}), simpleTransformation(isSet, 'set',\n// (sets only exist in es6+)\n// eslint-disable-next-line es5/no-es6-methods\nv => [...v.values()], v => new Set(v)), simpleTransformation(isMap, 'map', v => [...v.entries()], v => new Map(v)), simpleTransformation(v => isNaNValue(v) || isInfinite(v), 'number', v => {\n  if (isNaNValue(v)) {\n    return 'NaN';\n  }\n  if (v > 0) {\n    return 'Infinity';\n  } else {\n    return '-Infinity';\n  }\n}, Number), simpleTransformation(v => v === 0 && 1 / v === -Infinity, 'number', () => {\n  return '-0';\n}, Number), simpleTransformation(isURL, 'URL', v => v.toString(), v => new URL(v))];\nfunction compositeTransformation(isApplicable, annotation, transform, untransform) {\n  return {\n    isApplicable,\n    annotation,\n    transform,\n    untransform\n  };\n}\nconst symbolRule = compositeTransformation((s, superJson) => {\n  if (isSymbol(s)) {\n    const isRegistered = !!superJson.symbolRegistry.getIdentifier(s);\n    return isRegistered;\n  }\n  return false;\n}, (s, superJson) => {\n  const identifier = superJson.symbolRegistry.getIdentifier(s);\n  return ['symbol', identifier];\n}, v => v.description, (_, a, superJson) => {\n  const value = superJson.symbolRegistry.getValue(a[1]);\n  if (!value) {\n    throw new Error('Trying to deserialize unknown symbol');\n  }\n  return value;\n});\nconst constructorToName = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array, Uint8ClampedArray].reduce((obj, ctor) => {\n  obj[ctor.name] = ctor;\n  return obj;\n}, {});\nconst typedArrayRule = compositeTransformation(isTypedArray, v => ['typed-array', v.constructor.name], v => [...v], (v, a) => {\n  const ctor = constructorToName[a[1]];\n  if (!ctor) {\n    throw new Error('Trying to deserialize unknown typed array');\n  }\n  return new ctor(v);\n});\nexport function isInstanceOfRegisteredClass(potentialClass, superJson) {\n  if (potentialClass?.constructor) {\n    const isRegistered = !!superJson.classRegistry.getIdentifier(potentialClass.constructor);\n    return isRegistered;\n  }\n  return false;\n}\nconst classRule = compositeTransformation(isInstanceOfRegisteredClass, (clazz, superJson) => {\n  const identifier = superJson.classRegistry.getIdentifier(clazz.constructor);\n  return ['class', identifier];\n}, (clazz, superJson) => {\n  const allowedProps = superJson.classRegistry.getAllowedProps(clazz.constructor);\n  if (!allowedProps) {\n    return {\n      ...clazz\n    };\n  }\n  const result = {};\n  allowedProps.forEach(prop => {\n    result[prop] = clazz[prop];\n  });\n  return result;\n}, (v, a, superJson) => {\n  const clazz = superJson.classRegistry.getValue(a[1]);\n  if (!clazz) {\n    throw new Error('Trying to deserialize unknown class - check https://github.com/blitz-js/superjson/issues/116#issuecomment-773996564');\n  }\n  return Object.assign(Object.create(clazz.prototype), v);\n});\nconst customRule = compositeTransformation((value, superJson) => {\n  return !!superJson.customTransformerRegistry.findApplicable(value);\n}, (value, superJson) => {\n  const transformer = superJson.customTransformerRegistry.findApplicable(value);\n  return ['custom', transformer.name];\n}, (value, superJson) => {\n  const transformer = superJson.customTransformerRegistry.findApplicable(value);\n  return transformer.serialize(value);\n}, (v, a, superJson) => {\n  const transformer = superJson.customTransformerRegistry.findByName(a[1]);\n  if (!transformer) {\n    throw new Error('Trying to deserialize unknown custom value');\n  }\n  return transformer.deserialize(v);\n});\nconst compositeRules = [classRule, symbolRule, customRule, typedArrayRule];\nexport const transformValue = (value, superJson) => {\n  const applicableCompositeRule = findArr(compositeRules, rule => rule.isApplicable(value, superJson));\n  if (applicableCompositeRule) {\n    return {\n      value: applicableCompositeRule.transform(value, superJson),\n      type: applicableCompositeRule.annotation(value, superJson)\n    };\n  }\n  const applicableSimpleRule = findArr(simpleRules, rule => rule.isApplicable(value, superJson));\n  if (applicableSimpleRule) {\n    return {\n      value: applicableSimpleRule.transform(value, superJson),\n      type: applicableSimpleRule.annotation\n    };\n  }\n  return undefined;\n};\nconst simpleRulesByAnnotation = {};\nsimpleRules.forEach(rule => {\n  simpleRulesByAnnotation[rule.annotation] = rule;\n});\nexport const untransformValue = (json, type, superJson) => {\n  if (isArray(type)) {\n    switch (type[0]) {\n      case 'symbol':\n        return symbolRule.untransform(json, type, superJson);\n      case 'class':\n        return classRule.untransform(json, type, superJson);\n      case 'custom':\n        return customRule.untransform(json, type, superJson);\n      case 'typed-array':\n        return typedArrayRule.untransform(json, type, superJson);\n      default:\n        throw new Error('Unknown transformation: ' + type);\n    }\n  } else {\n    const transformation = simpleRulesByAnnotation[type];\n    if (!transformation) {\n      throw new Error('Unknown transformation: ' + type);\n    }\n    return transformation.untransform(json, superJson);\n  }\n};\n", "import { isMap, isArray, isPlainObject, isSet } from './is.js';\nimport { includes } from './util.js';\nconst getNthKey = (value, n) => {\n  const keys = value.keys();\n  while (n > 0) {\n    keys.next();\n    n--;\n  }\n  return keys.next().value;\n};\nfunction validatePath(path) {\n  if (includes(path, '__proto__')) {\n    throw new Error('__proto__ is not allowed as a property');\n  }\n  if (includes(path, 'prototype')) {\n    throw new Error('prototype is not allowed as a property');\n  }\n  if (includes(path, 'constructor')) {\n    throw new Error('constructor is not allowed as a property');\n  }\n}\nexport const getDeep = (object, path) => {\n  validatePath(path);\n  for (let i = 0; i < path.length; i++) {\n    const key = path[i];\n    if (isSet(object)) {\n      object = getNthKey(object, +key);\n    } else if (isMap(object)) {\n      const row = +key;\n      const type = +path[++i] === 0 ? 'key' : 'value';\n      const keyOfRow = getNthKey(object, row);\n      switch (type) {\n        case 'key':\n          object = keyOfRow;\n          break;\n        case 'value':\n          object = object.get(keyOfRow);\n          break;\n      }\n    } else {\n      object = object[key];\n    }\n  }\n  return object;\n};\nexport const setDeep = (object, path, mapper) => {\n  validatePath(path);\n  if (path.length === 0) {\n    return mapper(object);\n  }\n  let parent = object;\n  for (let i = 0; i < path.length - 1; i++) {\n    const key = path[i];\n    if (isArray(parent)) {\n      const index = +key;\n      parent = parent[index];\n    } else if (isPlainObject(parent)) {\n      parent = parent[key];\n    } else if (isSet(parent)) {\n      const row = +key;\n      parent = getNthKey(parent, row);\n    } else if (isMap(parent)) {\n      const isEnd = i === path.length - 2;\n      if (isEnd) {\n        break;\n      }\n      const row = +key;\n      const type = +path[++i] === 0 ? 'key' : 'value';\n      const keyOfRow = getNthKey(parent, row);\n      switch (type) {\n        case 'key':\n          parent = keyOfRow;\n          break;\n        case 'value':\n          parent = parent.get(keyOfRow);\n          break;\n      }\n    }\n  }\n  const lastKey = path[path.length - 1];\n  if (isArray(parent)) {\n    parent[+lastKey] = mapper(parent[+lastKey]);\n  } else if (isPlainObject(parent)) {\n    parent[lastKey] = mapper(parent[lastKey]);\n  }\n  if (isSet(parent)) {\n    const oldValue = getNthKey(parent, +lastKey);\n    const newValue = mapper(oldValue);\n    if (oldValue !== newValue) {\n      parent.delete(oldValue);\n      parent.add(newValue);\n    }\n  }\n  if (isMap(parent)) {\n    const row = +path[path.length - 2];\n    const keyToRow = getNthKey(parent, row);\n    const type = +lastKey === 0 ? 'key' : 'value';\n    switch (type) {\n      case 'key':\n        {\n          const newKey = mapper(keyToRow);\n          parent.set(newKey, parent.get(keyToRow));\n          if (newKey !== keyToRow) {\n            parent.delete(keyToRow);\n          }\n          break;\n        }\n      case 'value':\n        {\n          parent.set(keyToRow, mapper(parent.get(keyToRow)));\n          break;\n        }\n    }\n  }\n  return object;\n};\n", "import { isArray, isEmptyObject, isMap, isPlainObject, isPrimitive, isSet } from './is.js';\nimport { escapeKey, stringifyPath } from './pathstringifier.js';\nimport { isInstanceOfRegisteredClass, transformValue, untransformValue } from './transformer.js';\nimport { includes, forEach } from './util.js';\nimport { parsePath } from './pathstringifier.js';\nimport { getDeep, setDeep } from './accessDeep.js';\nfunction traverse(tree, walker, origin = []) {\n  if (!tree) {\n    return;\n  }\n  if (!isArray(tree)) {\n    forEach(tree, (subtree, key) => traverse(subtree, walker, [...origin, ...parsePath(key)]));\n    return;\n  }\n  const [nodeValue, children] = tree;\n  if (children) {\n    forEach(children, (child, key) => {\n      traverse(child, walker, [...origin, ...parsePath(key)]);\n    });\n  }\n  walker(nodeValue, origin);\n}\nexport function applyValueAnnotations(plain, annotations, superJson) {\n  traverse(annotations, (type, path) => {\n    plain = setDeep(plain, path, v => untransformValue(v, type, superJson));\n  });\n  return plain;\n}\nexport function applyReferentialEqualityAnnotations(plain, annotations) {\n  function apply(identicalPaths, path) {\n    const object = getDeep(plain, parsePath(path));\n    identicalPaths.map(parsePath).forEach(identicalObjectPath => {\n      plain = setDeep(plain, identicalObjectPath, () => object);\n    });\n  }\n  if (isArray(annotations)) {\n    const [root, other] = annotations;\n    root.forEach(identicalPath => {\n      plain = setDeep(plain, parsePath(identicalPath), () => plain);\n    });\n    if (other) {\n      forEach(other, apply);\n    }\n  } else {\n    forEach(annotations, apply);\n  }\n  return plain;\n}\nconst isDeep = (object, superJson) => isPlainObject(object) || isArray(object) || isMap(object) || isSet(object) || isInstanceOfRegisteredClass(object, superJson);\nfunction addIdentity(object, path, identities) {\n  const existingSet = identities.get(object);\n  if (existingSet) {\n    existingSet.push(path);\n  } else {\n    identities.set(object, [path]);\n  }\n}\nexport function generateReferentialEqualityAnnotations(identitites, dedupe) {\n  const result = {};\n  let rootEqualityPaths = undefined;\n  identitites.forEach(paths => {\n    if (paths.length <= 1) {\n      return;\n    }\n    // if we're not deduping, all of these objects continue existing.\n    // putting the shortest path first makes it easier to parse for humans\n    // if we're deduping though, only the first entry will still exist, so we can't do this optimisation.\n    if (!dedupe) {\n      paths = paths.map(path => path.map(String)).sort((a, b) => a.length - b.length);\n    }\n    const [representativePath, ...identicalPaths] = paths;\n    if (representativePath.length === 0) {\n      rootEqualityPaths = identicalPaths.map(stringifyPath);\n    } else {\n      result[stringifyPath(representativePath)] = identicalPaths.map(stringifyPath);\n    }\n  });\n  if (rootEqualityPaths) {\n    if (isEmptyObject(result)) {\n      return [rootEqualityPaths];\n    } else {\n      return [rootEqualityPaths, result];\n    }\n  } else {\n    return isEmptyObject(result) ? undefined : result;\n  }\n}\nexport const walker = (object, identities, superJson, dedupe, path = [], objectsInThisPath = [], seenObjects = new Map()) => {\n  const primitive = isPrimitive(object);\n  if (!primitive) {\n    addIdentity(object, path, identities);\n    const seen = seenObjects.get(object);\n    if (seen) {\n      // short-circuit result if we've seen this object before\n      return dedupe ? {\n        transformedValue: null\n      } : seen;\n    }\n  }\n  if (!isDeep(object, superJson)) {\n    const transformed = transformValue(object, superJson);\n    const result = transformed ? {\n      transformedValue: transformed.value,\n      annotations: [transformed.type]\n    } : {\n      transformedValue: object\n    };\n    if (!primitive) {\n      seenObjects.set(object, result);\n    }\n    return result;\n  }\n  if (includes(objectsInThisPath, object)) {\n    // prevent circular references\n    return {\n      transformedValue: null\n    };\n  }\n  const transformationResult = transformValue(object, superJson);\n  const transformed = transformationResult?.value ?? object;\n  const transformedValue = isArray(transformed) ? [] : {};\n  const innerAnnotations = {};\n  forEach(transformed, (value, index) => {\n    if (index === '__proto__' || index === 'constructor' || index === 'prototype') {\n      throw new Error(`Detected property ${index}. This is a prototype pollution risk, please remove it from your object.`);\n    }\n    const recursiveResult = walker(value, identities, superJson, dedupe, [...path, index], [...objectsInThisPath, object], seenObjects);\n    transformedValue[index] = recursiveResult.transformedValue;\n    if (isArray(recursiveResult.annotations)) {\n      innerAnnotations[index] = recursiveResult.annotations;\n    } else if (isPlainObject(recursiveResult.annotations)) {\n      forEach(recursiveResult.annotations, (tree, key) => {\n        innerAnnotations[escapeKey(index) + '.' + key] = tree;\n      });\n    }\n  });\n  const result = isEmptyObject(innerAnnotations) ? {\n    transformedValue,\n    annotations: !!transformationResult ? [transformationResult.type] : undefined\n  } : {\n    transformedValue,\n    annotations: !!transformationResult ? [transformationResult.type, innerAnnotations] : innerAnnotations\n  };\n  if (!primitive) {\n    seenObjects.set(object, result);\n  }\n  return result;\n};\n", "function getType(payload) {\n  return Object.prototype.toString.call(payload).slice(8, -1);\n}\nfunction isAnyObject(payload) {\n  return getType(payload) === \"Object\";\n}\nfunction isArray(payload) {\n  return getType(payload) === \"Array\";\n}\nfunction isBlob(payload) {\n  return getType(payload) === \"Blob\";\n}\nfunction isBoolean(payload) {\n  return getType(payload) === \"Boolean\";\n}\nfunction isDate(payload) {\n  return getType(payload) === \"Date\" && !isNaN(payload);\n}\nfunction isEmptyArray(payload) {\n  return isArray(payload) && payload.length === 0;\n}\nfunction isPlainObject(payload) {\n  if (getType(payload) !== \"Object\") return false;\n  const prototype = Object.getPrototypeOf(payload);\n  return !!prototype && prototype.constructor === Object && prototype === Object.prototype;\n}\nfunction isEmptyObject(payload) {\n  return isPlainObject(payload) && Object.keys(payload).length === 0;\n}\nfunction isEmptyString(payload) {\n  return payload === \"\";\n}\nfunction isError(payload) {\n  return getType(payload) === \"Error\" || payload instanceof Error;\n}\nfunction isFile(payload) {\n  return getType(payload) === \"File\";\n}\nfunction isFullArray(payload) {\n  return isArray(payload) && payload.length > 0;\n}\nfunction isFullObject(payload) {\n  return isPlainObject(payload) && Object.keys(payload).length > 0;\n}\nfunction isString(payload) {\n  return getType(payload) === \"String\";\n}\nfunction isFullString(payload) {\n  return isString(payload) && payload !== \"\";\n}\nfunction isFunction(payload) {\n  return typeof payload === \"function\";\n}\nfunction isType(payload, type) {\n  if (!(type instanceof Function)) {\n    throw new TypeError(\"Type must be a function\");\n  }\n  if (!Object.prototype.hasOwnProperty.call(type, \"prototype\")) {\n    throw new TypeError(\"Type is not a class\");\n  }\n  const name = type.name;\n  return getType(payload) === name || Boolean(payload && payload.constructor === type);\n}\nfunction isInstanceOf(value, classOrClassName) {\n  if (typeof classOrClassName === \"function\") {\n    for (let p = value; p; p = Object.getPrototypeOf(p)) {\n      if (isType(p, classOrClassName)) {\n        return true;\n      }\n    }\n    return false;\n  } else {\n    for (let p = value; p; p = Object.getPrototypeOf(p)) {\n      if (getType(p) === classOrClassName) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\nfunction isMap(payload) {\n  return getType(payload) === \"Map\";\n}\nfunction isNaNValue(payload) {\n  return getType(payload) === \"Number\" && isNaN(payload);\n}\nfunction isNumber(payload) {\n  return getType(payload) === \"Number\" && !isNaN(payload);\n}\nfunction isNegativeNumber(payload) {\n  return isNumber(payload) && payload < 0;\n}\nfunction isNull(payload) {\n  return getType(payload) === \"Null\";\n}\nfunction isOneOf(a, b, c, d, e) {\n  return value => a(value) || b(value) || !!c && c(value) || !!d && d(value) || !!e && e(value);\n}\nfunction isUndefined(payload) {\n  return getType(payload) === \"Undefined\";\n}\nconst isNullOrUndefined = isOneOf(isNull, isUndefined);\nfunction isObject(payload) {\n  return isPlainObject(payload);\n}\nfunction isObjectLike(payload) {\n  return isAnyObject(payload);\n}\nfunction isPositiveNumber(payload) {\n  return isNumber(payload) && payload > 0;\n}\nfunction isSymbol(payload) {\n  return getType(payload) === \"Symbol\";\n}\nfunction isPrimitive(payload) {\n  return isBoolean(payload) || isNull(payload) || isUndefined(payload) || isNumber(payload) || isString(payload) || isSymbol(payload);\n}\nfunction isPromise(payload) {\n  return getType(payload) === \"Promise\";\n}\nfunction isRegExp(payload) {\n  return getType(payload) === \"RegExp\";\n}\nfunction isSet(payload) {\n  return getType(payload) === \"Set\";\n}\nfunction isWeakMap(payload) {\n  return getType(payload) === \"WeakMap\";\n}\nfunction isWeakSet(payload) {\n  return getType(payload) === \"WeakSet\";\n}\nexport { getType, isAnyObject, isArray, isBlob, isBoolean, isDate, isEmptyArray, isEmptyObject, isEmptyString, isError, isFile, isFullArray, isFullObject, isFullString, isFunction, isInstanceOf, isMap, isNaNValue, isNegativeNumber, isNull, isNullOrUndefined, isNumber, isObject, isObjectLike, isOneOf, isPlainObject, isPositiveNumber, isPrimitive, isPromise, isRegExp, isSet, isString, isSymbol, isType, isUndefined, isWeakMap, isWeakSet };", "import { isArray, isPlainObject } from 'is-what';\nfunction assignProp(carry, key, newVal, originalObject, includeNonenumerable) {\n  const propType = {}.propertyIsEnumerable.call(originalObject, key) ? \"enumerable\" : \"nonenumerable\";\n  if (propType === \"enumerable\") carry[key] = newVal;\n  if (includeNonenumerable && propType === \"nonenumerable\") {\n    Object.defineProperty(carry, key, {\n      value: newVal,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    });\n  }\n}\nfunction copy(target, options = {}) {\n  if (isArray(target)) {\n    return target.map(item => copy(item, options));\n  }\n  if (!isPlainObject(target)) {\n    return target;\n  }\n  const props = Object.getOwnPropertyNames(target);\n  const symbols = Object.getOwnPropertySymbols(target);\n  return [...props, ...symbols].reduce((carry, key) => {\n    if (isArray(options.props) && !options.props.includes(key)) {\n      return carry;\n    }\n    const val = target[key];\n    const newVal = copy(val, options);\n    assignProp(carry, key, newVal, target, options.nonenumerable);\n    return carry;\n  }, {});\n}\nexport { copy };", "import { ClassRegistry } from './class-registry.js';\nimport { Registry } from './registry.js';\nimport { CustomTransformerRegistry } from './custom-transformer-registry.js';\nimport { applyReferentialEqualityAnnotations, applyValueAnnotations, generateReferentialEqualityAnnotations, walker } from './plainer.js';\nimport { copy } from 'copy-anything';\nexport default class SuperJSON {\n  /**\n   * @param dedupeReferentialEqualities  If true, SuperJSON will make sure only one instance of referentially equal objects are serialized and the rest are replaced with `null`.\n   */\n  constructor({\n    dedupe = false\n  } = {}) {\n    this.classRegistry = new ClassRegistry();\n    this.symbolRegistry = new Registry(s => s.description ?? '');\n    this.customTransformerRegistry = new CustomTransformerRegistry();\n    this.allowedErrorProps = [];\n    this.dedupe = dedupe;\n  }\n  serialize(object) {\n    const identities = new Map();\n    const output = walker(object, identities, this, this.dedupe);\n    const res = {\n      json: output.transformedValue\n    };\n    if (output.annotations) {\n      res.meta = {\n        ...res.meta,\n        values: output.annotations\n      };\n    }\n    const equalityAnnotations = generateReferentialEqualityAnnotations(identities, this.dedupe);\n    if (equalityAnnotations) {\n      res.meta = {\n        ...res.meta,\n        referentialEqualities: equalityAnnotations\n      };\n    }\n    return res;\n  }\n  deserialize(payload) {\n    const {\n      json,\n      meta\n    } = payload;\n    let result = copy(json);\n    if (meta?.values) {\n      result = applyValueAnnotations(result, meta.values, this);\n    }\n    if (meta?.referentialEqualities) {\n      result = applyReferentialEqualityAnnotations(result, meta.referentialEqualities);\n    }\n    return result;\n  }\n  stringify(object) {\n    return JSON.stringify(this.serialize(object));\n  }\n  parse(string) {\n    return this.deserialize(JSON.parse(string));\n  }\n  registerClass(v, options) {\n    this.classRegistry.register(v, options);\n  }\n  registerSymbol(v, identifier) {\n    this.symbolRegistry.register(v, identifier);\n  }\n  registerCustom(transformer, name) {\n    this.customTransformerRegistry.register({\n      name,\n      ...transformer\n    });\n  }\n  allowErrorProps(...props) {\n    this.allowedErrorProps.push(...props);\n  }\n}\nSuperJSON.defaultInstance = new SuperJSON();\nSuperJSON.serialize = SuperJSON.defaultInstance.serialize.bind(SuperJSON.defaultInstance);\nSuperJSON.deserialize = SuperJSON.defaultInstance.deserialize.bind(SuperJSON.defaultInstance);\nSuperJSON.stringify = SuperJSON.defaultInstance.stringify.bind(SuperJSON.defaultInstance);\nSuperJSON.parse = SuperJSON.defaultInstance.parse.bind(SuperJSON.defaultInstance);\nSuperJSON.registerClass = SuperJSON.defaultInstance.registerClass.bind(SuperJSON.defaultInstance);\nSuperJSON.registerSymbol = SuperJSON.defaultInstance.registerSymbol.bind(SuperJSON.defaultInstance);\nSuperJSON.registerCustom = SuperJSON.defaultInstance.registerCustom.bind(SuperJSON.defaultInstance);\nSuperJSON.allowErrorProps = SuperJSON.defaultInstance.allowErrorProps.bind(SuperJSON.defaultInstance);\nexport { SuperJSON };\nexport const serialize = SuperJSON.serialize;\nexport const deserialize = SuperJSON.deserialize;\nexport const stringify = SuperJSON.stringify;\nexport const parse = SuperJSON.parse;\nexport const registerClass = SuperJSON.registerClass;\nexport const registerCustom = SuperJSON.registerCustom;\nexport const registerSymbol = SuperJSON.registerSymbol;\nexport const allowErrorProps = SuperJSON.allowErrorProps;\n"],
  "mappings": "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",
  "names": ["walker", "transformed", "result", "getType", "isArray", "getType", "isPlainObject", "getType", "isNull", "getType", "isUndefined", "isArray", "isPlainObject"]
}
